{-
	Написать функцию reduce принимающую один целочисленный аргумент
	a и возвращающую 0, если аргумент делится на 3, a2, если он
	на 3 не делится и является при этом нечётным, a3 в остальных случаях. 
	Напишите для этой функции наименее ограничивающую аннотацию типов, 
	выяснив, какой класс типов достаточен для выполнения указанных операций.
-}

import System.Environment
import System.IO

reduce :: (Integral a) => a -> a
reduce a
        | a `mod` 3 == 0        = 0
        | a `mod` 2 == 0        = a^3
        | otherwise             = a^2


{- 
	Написать функцию, применяющую определённую выше функцию reduce 
	заданное количество раз к значению в контексте, являющемся функтором:
	reduceNF :: Functor f => Int -> f a -> f a
	Дан текстовый файл, содержащий пары положительных целых чисел в каждой 
	строке. Придумать способы преобразования этого списка к значению в 
	следующих контекстах:

    список;
    Maybe;
    Either;
    IO.

-}

--reduceNF :: Functor f => Int -> f a -> f b
--reduceNF n f a =  last $ take n $ iterate (fmap reduce) (f a)
